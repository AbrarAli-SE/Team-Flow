import { createContext, ReactNode, useMemo, useContext } from "react";
import { usePartySocket } from "partysocket/react";
import { useQueryClient } from "@tanstack/react-query";
import { ThreadEventSchema, RealTimeMessage, ThreadEvent } from "@/app/schemas/realtime";
import { orpc } from "@/lib/orpc";

type ThreadRealtimeContextValue = {
    send: (event: ThreadEvent) => void;
};

const ThreadRealtimeContext = createContext<null | ThreadRealtimeContextValue>(null);

interface ThreadRealtimeProviderProps {
    children: ReactNode;
    threadId: string;
}

type ThreadListOptions = ReturnType<typeof orpc.message.thread.list.queryOptions>;
type ThreadQueryData = Awaited<ReturnType<ThreadListOptions["queryFn"]>>;

export function ThreadRealtimeProvider({ children, threadId }: ThreadRealtimeProviderProps) {
    const queryClient = useQueryClient();

    const socket = usePartySocket({
        host: 'https://team-flow-chat-saad-realtime.abrarali-se.workers.dev',
        room: `thread-${threadId}`,
        party: "chat",
        onMessage(e) {
            try {
                const parsed = JSON.parse(e.data);
                const result = ThreadEventSchema.safeParse(parsed);
                if (!result.success) {
                    console.log("invalid thread event");
                    return;
                }
                const evt = result.data;

                if (evt.type === "thread:reply:created") {
                    const replyObject = evt.payload.message as RealTimeMessage;
                    // use the same key generated by orpc
                    const listOptions = orpc.message.thread.list.queryOptions({
                        input: { messageId: threadId }
                    });
                    queryClient.setQueryData<ThreadQueryData>(
                        listOptions.queryKey,
                        (oldData) => {
                            if (!oldData) return oldData;
                            const reply = {
                                reactions: Array.isArray(replyObject.reactions)
                                    ? replyObject.reactions
                                    : [],
                                ...replyObject,
                            } as ThreadQueryData["messages"][number];
                            return {
                                ...oldData,
                                messages: [...oldData.messages, reply]
                            };
                        }
                    );
                    return;
                }

                if (evt.type === "thread:reaction:updated") {
                    const { messageId, reactions, threadId: tId } = evt.payload;
                    if (tId !== threadId) return;
                    const listOptions = orpc.message.thread.list.queryOptions({
                        input: { messageId: threadId }
                    });
                    queryClient.setQueryData<ThreadQueryData>(
                        listOptions.queryKey,
                        (oldData) => {
                            if (!oldData) return oldData;
                            if (messageId === threadId) {
                                return {
                                    ...oldData,
                                    parent: {
                                        ...oldData.parent,
                                        reactions
                                    }
                                };
                            }
                            return {
                                ...oldData,
                                messages: oldData.messages.map((m) =>
                                    m.id === messageId
                                        ? { ...m, reactions }
                                        : m
                                )
                            };
                        }
                    );
                    return;
                }
            } catch {
                console.log("something went wrong");
            }
        }
    });

    const value = useMemo<ThreadRealtimeContextValue>(() => {
        return {
            send: (event) => {
                socket.send(JSON.stringify(event));
            },
        };
    }, [socket]);

    return (
        <ThreadRealtimeContext.Provider value={value}>
            {children}
        </ThreadRealtimeContext.Provider>
    );
}

export function useThreadRealtime() {
    const context = useContext(ThreadRealtimeContext);
    if (!context) {
        throw new Error("useThreadRealtime must be used within a ThreadRealtimeProvider");
    }
    return context;
}

export function useOptionalThreadRealtime(): ThreadRealtimeContextValue | null {
    return useContext(ThreadRealtimeContext);
}